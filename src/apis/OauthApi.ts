/* tslint:disable */
/* eslint-disable */
/**
 * DoorFlow API
 * Access control and door management API for DoorFlow
 *
 * The version of the OpenAPI document: 3.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  GetAccessToken200Response,
  GetAccessToken400Response,
  GetAccessToken401Response,
  GetTokenInfo200Response,
  GetTokenInfo401Response,
  RevokeToken403Response,
} from '../models/index';
import {
    GetAccessToken200ResponseFromJSON,
    GetAccessToken200ResponseToJSON,
    GetAccessToken400ResponseFromJSON,
    GetAccessToken400ResponseToJSON,
    GetAccessToken401ResponseFromJSON,
    GetAccessToken401ResponseToJSON,
    GetTokenInfo200ResponseFromJSON,
    GetTokenInfo200ResponseToJSON,
    GetTokenInfo401ResponseFromJSON,
    GetTokenInfo401ResponseToJSON,
    RevokeToken403ResponseFromJSON,
    RevokeToken403ResponseToJSON,
} from '../models/index';

export interface AuthorizeOAuthRequest {
    responseType: AuthorizeOAuthResponseTypeEnum;
    clientId: string;
    redirectUri: string;
    scope: string;
    state?: string;
    codeChallenge?: string;
    codeChallengeMethod?: AuthorizeOAuthCodeChallengeMethodEnum;
}

export interface GetAccessTokenRequest {
    grantType: GetAccessTokenGrantTypeEnum;
    clientId?: string;
    clientSecret?: string;
    code?: string;
    redirectUri?: string;
    codeVerifier?: string;
    refreshToken?: string;
    scope?: string;
}

export interface RevokeTokenRequest {
    authorization: string;
    token: string;
    tokenTypeHint?: RevokeTokenTokenTypeHintEnum;
}

/**
 * 
 */
export class OauthApi extends runtime.BaseAPI {

    /**
     * Initiates the OAuth 2.0 authorization code flow. Direct users to this endpoint to request authorization.  **Authorization Code Flow Steps:** 1. Direct the user\'s browser to this endpoint with required parameters 2. User logs in (if not already authenticated) and authorizes your application 3. User is redirected to your `redirect_uri` with an authorization `code` parameter 4. Exchange the code for an access token at `/oauth/token`  **PKCE (Proof Key for Code Exchange):** For public clients (mobile/SPA applications), PKCE is recommended for security: 1. Generate a random `code_verifier` (43-128 characters) 2. Create `code_challenge` = BASE64URL(SHA256(code_verifier)) 3. Include `code_challenge` and `code_challenge_method=S256` in this request 4. Include `code_verifier` when exchanging the code at `/oauth/token`  **Important Notes:** - This is a browser-based flow - users will see a login/authorization screen - The `redirect_uri` must be pre-registered with your OAuth application - The authorization code expires after 10 minutes - Some applications may be configured to skip the authorization screen (auto-approve) 
     * Authorization endpoint
     */
    async authorizeOAuthRaw(requestParameters: AuthorizeOAuthRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['responseType'] == null) {
            throw new runtime.RequiredError(
                'responseType',
                'Required parameter "responseType" was null or undefined when calling authorizeOAuth().'
            );
        }

        if (requestParameters['clientId'] == null) {
            throw new runtime.RequiredError(
                'clientId',
                'Required parameter "clientId" was null or undefined when calling authorizeOAuth().'
            );
        }

        if (requestParameters['redirectUri'] == null) {
            throw new runtime.RequiredError(
                'redirectUri',
                'Required parameter "redirectUri" was null or undefined when calling authorizeOAuth().'
            );
        }

        if (requestParameters['scope'] == null) {
            throw new runtime.RequiredError(
                'scope',
                'Required parameter "scope" was null or undefined when calling authorizeOAuth().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['responseType'] != null) {
            queryParameters['response_type'] = requestParameters['responseType'];
        }

        if (requestParameters['clientId'] != null) {
            queryParameters['client_id'] = requestParameters['clientId'];
        }

        if (requestParameters['redirectUri'] != null) {
            queryParameters['redirect_uri'] = requestParameters['redirectUri'];
        }

        if (requestParameters['scope'] != null) {
            queryParameters['scope'] = requestParameters['scope'];
        }

        if (requestParameters['state'] != null) {
            queryParameters['state'] = requestParameters['state'];
        }

        if (requestParameters['codeChallenge'] != null) {
            queryParameters['code_challenge'] = requestParameters['codeChallenge'];
        }

        if (requestParameters['codeChallengeMethod'] != null) {
            queryParameters['code_challenge_method'] = requestParameters['codeChallengeMethod'];
        }

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/oauth/authorize`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Initiates the OAuth 2.0 authorization code flow. Direct users to this endpoint to request authorization.  **Authorization Code Flow Steps:** 1. Direct the user\'s browser to this endpoint with required parameters 2. User logs in (if not already authenticated) and authorizes your application 3. User is redirected to your `redirect_uri` with an authorization `code` parameter 4. Exchange the code for an access token at `/oauth/token`  **PKCE (Proof Key for Code Exchange):** For public clients (mobile/SPA applications), PKCE is recommended for security: 1. Generate a random `code_verifier` (43-128 characters) 2. Create `code_challenge` = BASE64URL(SHA256(code_verifier)) 3. Include `code_challenge` and `code_challenge_method=S256` in this request 4. Include `code_verifier` when exchanging the code at `/oauth/token`  **Important Notes:** - This is a browser-based flow - users will see a login/authorization screen - The `redirect_uri` must be pre-registered with your OAuth application - The authorization code expires after 10 minutes - Some applications may be configured to skip the authorization screen (auto-approve) 
     * Authorization endpoint
     */
    async authorizeOAuth(requestParameters: AuthorizeOAuthRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.authorizeOAuthRaw(requestParameters, initOverrides);
    }

    /**
     * Exchange authorization code for an access token, or refresh an existing token.  **Authorization Code Flow:** 1. Direct users to `/oauth/authorize` with your client_id, redirect_uri, and requested scopes 2. User authorizes your application 3. You receive an authorization code at your redirect_uri 4. Exchange the code for an access token using this endpoint with `grant_type=authorization_code`  **Refreshing Tokens:** - Use `grant_type=refresh_token` with a valid refresh_token to obtain a new access token - Access tokens expire after 1 hour - Refresh tokens are long-lived and should be stored securely 
     * Obtain access token
     */
    async getAccessTokenRaw(requestParameters: GetAccessTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetAccessToken200Response>> {
        if (requestParameters['grantType'] == null) {
            throw new runtime.RequiredError(
                'grantType',
                'Required parameter "grantType" was null or undefined when calling getAccessToken().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['grantType'] != null) {
            formParams.append('grant_type', requestParameters['grantType'] as any);
        }

        if (requestParameters['clientId'] != null) {
            formParams.append('client_id', requestParameters['clientId'] as any);
        }

        if (requestParameters['clientSecret'] != null) {
            formParams.append('client_secret', requestParameters['clientSecret'] as any);
        }

        if (requestParameters['code'] != null) {
            formParams.append('code', requestParameters['code'] as any);
        }

        if (requestParameters['redirectUri'] != null) {
            formParams.append('redirect_uri', requestParameters['redirectUri'] as any);
        }

        if (requestParameters['codeVerifier'] != null) {
            formParams.append('code_verifier', requestParameters['codeVerifier'] as any);
        }

        if (requestParameters['refreshToken'] != null) {
            formParams.append('refresh_token', requestParameters['refreshToken'] as any);
        }

        if (requestParameters['scope'] != null) {
            formParams.append('scope', requestParameters['scope'] as any);
        }


        let urlPath = `/oauth/token`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetAccessToken200ResponseFromJSON(jsonValue));
    }

    /**
     * Exchange authorization code for an access token, or refresh an existing token.  **Authorization Code Flow:** 1. Direct users to `/oauth/authorize` with your client_id, redirect_uri, and requested scopes 2. User authorizes your application 3. You receive an authorization code at your redirect_uri 4. Exchange the code for an access token using this endpoint with `grant_type=authorization_code`  **Refreshing Tokens:** - Use `grant_type=refresh_token` with a valid refresh_token to obtain a new access token - Access tokens expire after 1 hour - Refresh tokens are long-lived and should be stored securely 
     * Obtain access token
     */
    async getAccessToken(requestParameters: GetAccessTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetAccessToken200Response> {
        const response = await this.getAccessTokenRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns information about the current access token being used for authentication.  This endpoint provides metadata about the access token including the resource owner, account, scopes, and expiration.  **Authentication:** Requires a valid OAuth2 access token in the Authorization header. 
     * Get token information
     */
    async getTokenInfoRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetTokenInfo200Response>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", []);
        }


        let urlPath = `/oauth/token/info`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetTokenInfo200ResponseFromJSON(jsonValue));
    }

    /**
     * Returns information about the current access token being used for authentication.  This endpoint provides metadata about the access token including the resource owner, account, scopes, and expiration.  **Authentication:** Requires a valid OAuth2 access token in the Authorization header. 
     * Get token information
     */
    async getTokenInfo(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetTokenInfo200Response> {
        const response = await this.getTokenInfoRaw(initOverrides);
        return await response.value();
    }

    /**
     * Revokes an access token or refresh token, immediately invalidating it and blocking associated tokens from making further requests.  **When to revoke:** - User disconnects their DoorFlow account from your integration - User logs out - Security breach - revoke compromised tokens - Application uninstall  **Important:** - **We recommend revoking the refresh_token** - this will invalidate all associated access tokens - Returns HTTP 200 even if the token was already invalid (prevents token scanning attacks) - Client authentication is required via HTTP Basic Auth header  **Authentication:** You must authenticate using HTTP Basic Authentication with your client credentials: 1. Combine your client_id and client_secret as: `{client_id}:{client_secret}` 2. Encode using URL-safe Base64 3. Include in Authorization header: `Authorization: Basic {encoded_credentials}` 
     * Revoke access token or refresh token
     */
    async revokeTokenRaw(requestParameters: RevokeTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters['authorization'] == null) {
            throw new runtime.RequiredError(
                'authorization',
                'Required parameter "authorization" was null or undefined when calling revokeToken().'
            );
        }

        if (requestParameters['token'] == null) {
            throw new runtime.RequiredError(
                'token',
                'Required parameter "token" was null or undefined when calling revokeToken().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['authorization'] != null) {
            headerParameters['Authorization'] = String(requestParameters['authorization']);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['token'] != null) {
            formParams.append('token', requestParameters['token'] as any);
        }

        if (requestParameters['tokenTypeHint'] != null) {
            formParams.append('token_type_hint', requestParameters['tokenTypeHint'] as any);
        }


        let urlPath = `/oauth/revoke`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Revokes an access token or refresh token, immediately invalidating it and blocking associated tokens from making further requests.  **When to revoke:** - User disconnects their DoorFlow account from your integration - User logs out - Security breach - revoke compromised tokens - Application uninstall  **Important:** - **We recommend revoking the refresh_token** - this will invalidate all associated access tokens - Returns HTTP 200 even if the token was already invalid (prevents token scanning attacks) - Client authentication is required via HTTP Basic Auth header  **Authentication:** You must authenticate using HTTP Basic Authentication with your client credentials: 1. Combine your client_id and client_secret as: `{client_id}:{client_secret}` 2. Encode using URL-safe Base64 3. Include in Authorization header: `Authorization: Basic {encoded_credentials}` 
     * Revoke access token or refresh token
     */
    async revokeToken(requestParameters: RevokeTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.revokeTokenRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const AuthorizeOAuthResponseTypeEnum = {
    Code: 'code'
} as const;
export type AuthorizeOAuthResponseTypeEnum = typeof AuthorizeOAuthResponseTypeEnum[keyof typeof AuthorizeOAuthResponseTypeEnum];
/**
 * @export
 */
export const AuthorizeOAuthCodeChallengeMethodEnum = {
    S256: 'S256'
} as const;
export type AuthorizeOAuthCodeChallengeMethodEnum = typeof AuthorizeOAuthCodeChallengeMethodEnum[keyof typeof AuthorizeOAuthCodeChallengeMethodEnum];
/**
 * @export
 */
export const GetAccessTokenGrantTypeEnum = {
    AuthorizationCode: 'authorization_code',
    RefreshToken: 'refresh_token'
} as const;
export type GetAccessTokenGrantTypeEnum = typeof GetAccessTokenGrantTypeEnum[keyof typeof GetAccessTokenGrantTypeEnum];
/**
 * @export
 */
export const RevokeTokenTokenTypeHintEnum = {
    AccessToken: 'access_token',
    RefreshToken: 'refresh_token'
} as const;
export type RevokeTokenTokenTypeHintEnum = typeof RevokeTokenTokenTypeHintEnum[keyof typeof RevokeTokenTokenTypeHintEnum];
